# Production Docker Compose Configuration
# For use with VPS deployments (Coolify, etc.)
#
# Usage:
#   docker-compose -f docker-compose.prod.yml up -d
#
# IMPORTANT: Set your environment variables in a .env file or through your deployment platform

services:
  # Production database (External recommended - use managed PostgreSQL)
  # Uncomment if you want to run PostgreSQL in Docker
  # postgres:
  #   image: postgres:15-alpine
  #   container_name: openrevenue-postgres-prod
  #   restart: always
  #   environment:
  #     POSTGRES_DB: ${POSTGRES_DB:-openrevenue}
  #     POSTGRES_USER: ${POSTGRES_USER:-openrevenue}
  #     POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
  #   volumes:
  #     - postgres_data:/var/lib/postgresql/data
  #     - ./backups:/backups
  #   healthcheck:
  #     test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-openrevenue}"]
  #     interval: 10s
  #     timeout: 5s
  #     retries: 5
  #   networks:
  #     - openrevenue

  # Production Redis (External recommended - use managed Redis)
  # Uncomment if you want to run Redis in Docker
  # redis:
  #   image: redis:7-alpine
  #   container_name: openrevenue-redis-prod
  #   restart: always
  #   command: redis-server --requirepass ${REDIS_PASSWORD}
  #   volumes:
  #     - redis_data:/data
  #   healthcheck:
  #     test: ["CMD", "redis-cli", "--raw", "incr", "ping"]
  #     interval: 10s
  #     timeout: 3s
  #     retries: 5
  #   networks:
  #     - openrevenue

  # Main Platform (Production)
  platform:
    build:
      context: .
      dockerfile: apps/platform/Dockerfile
      args:
        - NODE_ENV=production
    container_name: openrevenue-platform-prod
    restart: always
    ports:
      - "${PORT:-5100}:5100"
    environment:
      - NODE_ENV=production
      - DATABASE_URL=${DATABASE_URL}
      - REDIS_URL=${REDIS_URL}
      - NEXTAUTH_SECRET=${NEXTAUTH_SECRET}
      - NEXTAUTH_URL=${NEXTAUTH_URL}
      - NEXT_PUBLIC_APP_URL=${NEXT_PUBLIC_APP_URL}
      - BETTER_AUTH_URL=${BETTER_AUTH_URL}
      - BETTER_AUTH_SECRET=${BETTER_AUTH_SECRET}
      - ENCRYPTION_KEY=${ENCRYPTION_KEY}
      - SIGNING_PRIVATE_KEY=${SIGNING_PRIVATE_KEY}
      # OAuth Providers
      - GOOGLE_CLIENT_ID=${GOOGLE_CLIENT_ID:-}
      - GOOGLE_CLIENT_SECRET=${GOOGLE_CLIENT_SECRET:-}
      - GITHUB_CLIENT_ID=${GITHUB_CLIENT_ID:-}
      - GITHUB_CLIENT_SECRET=${GITHUB_CLIENT_SECRET:-}
      # Payment Processors
      - STRIPE_SECRET_KEY=${STRIPE_SECRET_KEY:-}
      - STRIPE_WEBHOOK_SECRET=${STRIPE_WEBHOOK_SECRET:-}
      - PADDLE_VENDOR_ID=${PADDLE_VENDOR_ID:-}
      - PADDLE_API_KEY=${PADDLE_API_KEY:-}
      - PADDLE_PUBLIC_KEY=${PADDLE_PUBLIC_KEY:-}
      - LEMON_SQUEEZY_API_KEY=${LEMON_SQUEEZY_API_KEY:-}
      - PAYPAL_CLIENT_ID=${PAYPAL_CLIENT_ID:-}
      - PAYPAL_CLIENT_SECRET=${PAYPAL_CLIENT_SECRET:-}
      # Email
      - RESEND_API_KEY=${RESEND_API_KEY:-}
      - FROM_EMAIL=${FROM_EMAIL:-}
      # Analytics
      - SENTRY_DSN=${SENTRY_DSN:-}
      - PLAUSIBLE_DOMAIN=${PLAUSIBLE_DOMAIN:-}
      # Feature Flags
      - ENABLE_PADDLE=${ENABLE_PADDLE:-true}
      - ENABLE_LEMON_SQUEEZY=${ENABLE_LEMON_SQUEEZY:-true}
      - ENABLE_PAYPAL=${ENABLE_PAYPAL:-false}
      # Docker specific
      - PORT=5100
      - HOSTNAME=0.0.0.0
      - SKIP_MIGRATIONS=${SKIP_MIGRATIONS:-false}
    # Uncomment if using Docker PostgreSQL/Redis
    # depends_on:
    #   postgres:
    #     condition: service_healthy
    #   redis:
    #     condition: service_healthy
    networks:
      - openrevenue
    healthcheck:
      test: ["CMD", "node", "-e", "require('http').get('http://localhost:5100/api/health', (r) => {process.exit(r.statusCode === 200 ? 0 : 1)})"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    # Resource limits for production
    deploy:
      resources:
        limits:
          cpus: '2'
          memory: 2G
        reservations:
          cpus: '1'
          memory: 512M
    # Logging configuration
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  # Standalone app (Optional - for self-hosting data provider)
  standalone:
    build:
      context: .
      dockerfile: packages/standalone/Dockerfile
    container_name: openrevenue-standalone-prod
    restart: always
    ports:
      - "3001:3001"
    volumes:
      - standalone_data:/app/data
      - standalone_logs:/app/logs
    environment:
      - NODE_ENV=production
      - JWT_SECRET=${STANDALONE_JWT_SECRET}
      - SESSION_SECRET=${STANDALONE_SESSION_SECRET}
      - SIGNING_PRIVATE_KEY=${STANDALONE_SIGNING_PRIVATE_KEY}
      - SYNC_INTERVAL=${STANDALONE_SYNC_INTERVAL:-24}
      - API_PORT=3001
      - WEB_UI_ENABLED=${STANDALONE_WEB_UI_ENABLED:-true}
      - STARTUP_NAME=${STANDALONE_STARTUP_NAME}
      - STARTUP_DESCRIPTION=${STANDALONE_STARTUP_DESCRIPTION}
      # Payment processor credentials for standalone app
      - STRIPE_SECRET_KEY=${STANDALONE_STRIPE_SECRET_KEY:-}
      - PADDLE_API_KEY=${STANDALONE_PADDLE_API_KEY:-}
    networks:
      - openrevenue
    healthcheck:
      test: ["CMD", "node", "-e", "require('http').get('http://localhost:3001/health', (r) => {process.exit(r.statusCode === 200 ? 0 : 1)})"]
      interval: 30s
      timeout: 3s
      retries: 3
      start_period: 10s
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 512M
        reservations:
          cpus: '0.5'
          memory: 256M
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

volumes:
  # Uncomment if using Docker PostgreSQL/Redis
  # postgres_data:
  #   driver: local
  # redis_data:
  #   driver: local
  standalone_data:
    driver: local
  standalone_logs:
    driver: local

networks:
  openrevenue:
    driver: bridge
